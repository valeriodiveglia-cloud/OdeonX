import { NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { createClient } from '@supabase/supabase-js'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

type Role = 'owner' | 'admin' | 'staff'
type DeleteBody = {
  accountId?: string | number | null
  userId?: string | null
  email?: string | null
}

function svc() {
  // Service role SOLO dopo aver autorizzato il caller
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

function anonWithBearer(authorization: string) {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { global: { headers: { Authorization: authorization } } }
  )
}

// Blocca metodi diversi da POST
export async function GET() {
  return NextResponse.json({ error: 'Method Not Allowed' }, { status: 405 })
}
export async function PUT() {
  return NextResponse.json({ error: 'Method Not Allowed' }, { status: 405 })
}
export async function DELETE() {
  return NextResponse.json({ error: 'Method Not Allowed' }, { status: 405 })
}

export async function POST(req: Request) {
  try {
    // 1) Auth: cookie (@supabase/auth-helpers) OPPURE Authorization: Bearer <access_token>
    const authHeader = req.headers.get('authorization') || req.headers.get('Authorization') || ''
    const useBearer = /^Bearer\s+/.test(authHeader)
    const userClient = useBearer
      ? anonWithBearer(authHeader)
      : createRouteHandlerClient({ cookies })

    const { data: meAuth, error: meAuthErr } = await userClient.auth.getUser()
    if (meAuthErr || !meAuth?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // 2) Autorizzazione (deve essere owner o admin) usando le RPC in contesto utente
    const { data: isOwner } = await userClient.rpc('app_is_owner')
    const { data: isAdmin } = await userClient.rpc('app_is_admin')
    if (!isOwner && !isAdmin) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // 3) Parse body robusto
    let bodyUnknown: unknown
    try {
      bodyUnknown = await req.json()
    } catch {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 })
    }
    const body = (bodyUnknown ?? {}) as DeleteBody
    const accountId = body?.accountId
    const userId = body?.userId ?? null
    const email = (body?.email ?? null)?.toString().trim().toLowerCase() || null

    if (!accountId && !userId && !email) {
      return NextResponse.json({ error: 'Missing identifiers' }, { status: 400 })
    }

    // 4) Individua target tramite service role (niente sorprese da RLS)
    const db = svc()

    const orFilters: string[] = []
    if (accountId) orFilters.push(`id.eq.${accountId}`)
    if (userId && !accountId) orFilters.push(`user_id.eq.${userId}`)
    if (email && !accountId && !userId) orFilters.push(`email.eq.${email}`)

    const { data: target, error: tErr } = await db
      .from('app_accounts')
      .select('id, user_id, email, role')
      .or(orFilters.join(','))
      .maybeSingle()

    if (tErr) return NextResponse.json({ error: tErr.message }, { status: 400 })
    if (!target) return NextResponse.json({ error: 'Account not found' }, { status: 404 })

    // 5) Guard rail: evitare auto-cancellazione tramite endpoint
    if (target.user_id && target.user_id === meAuth.user.id) {
      return NextResponse.json({ error: 'Cannot delete your own account via this endpoint' }, { status: 400 })
    }

    // 6) Regole: admin solo staff; owner tutti MA non lâ€™ultimo owner
    const myRole: Role = isOwner ? 'owner' : (isAdmin ? 'admin' : 'staff')
    if (myRole === 'admin' && target.role !== 'staff') {
      return NextResponse.json({ error: 'Admins can delete staff only' }, { status: 403 })
    }

    if (target.role === 'owner') {
      const { count: ownersCount, error: cntErr } = await db
        .from('app_accounts')
        .select('id', { count: 'exact', head: true })
        .eq('role', 'owner')
      if (cntErr) return NextResponse.json({ error: cntErr.message }, { status: 400 })
      if ((ownersCount ?? 0) <= 1) {
        return NextResponse.json({ error: 'Cannot delete the last owner' }, { status: 403 })
      }
      if (myRole !== 'owner') {
        return NextResponse.json({ error: 'Only owners can delete owners' }, { status: 403 })
      }
    }

    // 7) Delete in Auth (se identificabile)
    let uid = target.user_id || userId || null
    if (!uid && email) {
      const byEmail = await db.auth.admin.getUserByEmail(email)
      uid = byEmail.data?.user?.id ?? null
    }
    if (uid) {
      const delAuth = await db.auth.admin.deleteUser(uid)
      if (delAuth.error) {
        return NextResponse.json({ error: `Auth delete failed: ${delAuth.error.message}` }, { status: 400 })
      }
    }

    // 8) Delete DB row (una sola volta)
    const { error: delDbErr } = await db.from('app_accounts').delete().eq('id', target.id)
    if (delDbErr) {
      return NextResponse.json({ error: `DB delete failed: ${delDbErr.message}` }, { status: 400 })
    }

    return NextResponse.json({ ok: true })
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Internal Server Error' }, { status: 500 })
  }
}
